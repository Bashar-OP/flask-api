Task Instructions
Step 1: Project Setup
Create a new folder and virtual environment
Install required packages:

    flask

flask_sqlalchemyflask_migratepython-dotenvUse SQLite---

Step 2: App Factory + Config
Use an app factory to create the Flask app
Configure the app with database URI and secret keyInitialize SQLAlchemy and Flask-Migrate
---

Step 3: Models
Create two models: Library and Book
Define a one-to-many relationship: a library can have many booksAdd relevant fields:

    Library: id, name

Book: id, title, author, library_id, created_at
---

Step 4: CRUD Routes
Create routes for libraries:

    Create, list, update, delete

Create routes for books:

    Create, list, update, delete

Use JSON requests and responses
---

Step 5: Migrations
Initialize Flask-Migrate
Create initial migration for the tablesApply migrations to the database
---

Step 6: Run the App
Use a run.py file to start the Flask app
Test CRUD routes using Postman, curl, or a browser
---

Step 7: Additional Features
Filter books by library
Search books by title or authorGet all books under a library



Create a controller file to implement the logic for creating, updating, deleting users — keeps routes simple and makes logic reusable and testable.

-Folder structure: include a routes/ folder, one file per endpoint, importing functions from the controller — organizes code and separates HTTP handling from business logic.

-Path Parameters for Update/Delete: send the resource ID as a path parameter —  clearly identifies the resource.

-Keep HTTP status codes in a constants file — improves readability and consistency across the codebase.

-Store sensitive info in environment variables and provide an .env.example — keeps secrets safe and makes setup easier for others.

-Handle errors before the database: validate inputs and catch errors at the application level — prevents unnecessary database calls and returns cleaner error messages.